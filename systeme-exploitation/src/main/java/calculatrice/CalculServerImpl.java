package calculatrice;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.rmi.AccessException;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.HashMap;

public class CalculServerImpl extends UnicastRemoteObject implements
		CalculServer {

	private static final long serialVersionUID = 65300214135859767L;
	private static final String NAME = "calculServer";

	private final HashMap<Long, Event> _events= new HashMap<Long, Event>();

	private boolean _running;
	private final Registry _registry;

	public CalculServerImpl(int port) throws RemoteException {

		// Create RMI
		_registry = LocateRegistry.createRegistry(port);
		_registry.rebind(NAME, this);

		try {
			String address = (InetAddress.getLocalHost()).toString();
			System.out.println("Server running @ " + address + ":" + port);
		} catch (UnknownHostException e) {
			System.err.println("Can't determine adress.");
		}

		// Set running
		_running = true;

		// Create UI
		(new Thread(new CalculServerUI(this))).start();

	}

	/**
	 * Add
	 */
	public synchronized String calculEvent(Event e) throws RemoteException {
		long id = e.getBegin().getTime();
		while (_events.get(id) != null) {
			id++;
		}
		e.setId(id);

		// Store id -> event
		_events.put(id, e);

		System.out.println("calcul event created with id: "+id+
				" operation is "+e.getOperation());
		
		return doCalculate(e);
	}



	private String doCalculate(final Event e) {
		int result =0;
		switch (e.getOperation()) {
		case ADD:
				for (Integer op : e.getOperande()) {
					result+=op;
				}
				e.setResult(String.valueOf(result));
			break;
		case MULTIPLY:
			result= 1;
			for (Integer op : e.getOperande()) {
				result*=op;
			}
			e.setResult(String.valueOf(result));
			break;
		case MODE:
			try {
				result = e.getOperande().get(0);
				if(e.getOperande().size()>1)
					for(int j= 1; j< e.getOperande().size();j++){
						result%=e.getOperande().get(j);
					}
				e.setResult(String.valueOf(result));
			} catch (ArithmeticException e1) {
				System.err.println("-Stop- ZERO division not authorized");
				e1.printStackTrace();
			}
			break;
		case DIV:
			try {
				result = e.getOperande().get(0);
				if(e.getOperande().size()>1)
					for(int j= 1; j< e.getOperande().size();j++){
						result/=e.getOperande().get(j);
					}
				e.setResult(String.valueOf(result));
			} catch (ArithmeticException e1) {
				System.err.println("-Stop- ZERO division not authorized");
				e1.printStackTrace();
			}

		default:
			break;
		}
		return e.getResult();
	}

	/**
	 * Close the server
	 */
	public void close() {

		_running = false;

		// Close RMI
		try {
			_registry.unbind(NAME);
		} catch (AccessException e) {
			System.err.println("Can't close server.");
		} catch (RemoteException e) {
			System.err.println("Can't close server.");
		} catch (NotBoundException e) {
			System.err.println("Can't close server.");
		}
	}

	/**
	 * Server running?
	 */
	public boolean running() {
		return _running;
	}
}